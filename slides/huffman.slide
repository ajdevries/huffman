Concurrency Patterns in Go

Alten Playground
9 May 2017


Albert-Jan de Vries
Ammar Abdulamir

* Why

Different perspective on concurrency, using builtin language features

* What

0. What is concurrency
1. Go routines
2. Channels

* What is concurrency?

Concurrency is the composition of independently executing computations.

Concurrency is a way to structure software, particularly as a way to write clean code that interacts well with the real world.

It is not parallelism.

- Rob (Commander) Pike

* Concurrency is not parallelism

Concurrency is not parallelism, although it enables parallelism.

If you have only one processor, your program can still be concurrent but it cannot be parallel.

On the other hand, a well-written concurrent program might run efficiently in parallel on a multiprocessor. That property could be important...

- Rob Pike

* Go routines
.play code/boring.go /START/,/STOP.*/

* Running it concurrent

Using a go routine

.play -edit code/waitgoboring.go /func.main/,/^}/

* Goroutines

What is a goroutine? It's an independently executing function, launched by a go statement.

It has its own call stack, which grows and shrinks as required.

It's very cheap. It's practical to have thousands, even hundreds of thousands of goroutines.

It's not a thread.

There might be only one thread in a program with thousands of goroutines.

Instead, goroutines are multiplexed dynamically onto threads as needed to keep all the goroutines running.

But if you think of it as a very cheap thread, you won't be far off.

* Channels

A channel in Go provides a connection between two goroutines, allowing them to communicate.

.code code/helpers.go /START1/,/STOP1/
.code code/helpers.go /START2/,/STOP2/
.code code/helpers.go /START3/,/STOP3/

* Using channels

A channel connects the main and boring goroutines so they can communicate.

.play code/changoboring.go /START1/,/STOP1/
.code code/changoboring.go /START2/,/STOP2/

* Channel read/writes are blocking

Write to a channel

.play code/channels_write.go /START/,/STOP.*/

Read from a channel

.play -edit code/channels_read.go /START/,/STOP.*/

* Buffered channels

.play -edit code/channels_buffered.go /START/,/STOP.*/

* Select

The select statement provides another way to handle multiple channels.
It's like a switch, but each case is a communication:
- All channels are evaluated.
- Selection blocks until one communication can proceed, which then does.
- If multiple can proceed, select chooses pseudo-randomly.
- A default clause, if present, executes immediately if no channel is ready.

.code code/select.go /START0/,/STOP0/

* Timeout using select

The time.After function returns a channel that blocks for the specified duration.
After the interval, the channel delivers the current time, once.

.play code/timeout.go /START1/,/STOP1/

* Timeout for whole conversation using select

Create the timer once, outside the loop, to time out the entire conversation.
(In the previous program, we had a timeout for each message.)

.play code/timeoutall.go /START1/,/STOP1/

* Function passing

* Huffman project
- Huffman tree
- Server endpoints
- Client download

* Install GO

- Download from https://golang.org/dl/
- Install Atom https://atom.io/ + go-plus
- Install Gogland https://www.jetbrains.com/go/
- Visual Studio Code (https://marketplace.visualstudio.com/items?itemName=lukehoban.Go)

* Present Rate Limiter Solution

* Second assignment

- Rate limit based a time frame (i.e. max 20 request in 1 minute)

* Third assignment

- Use third party server for download tree nodes
- Build a timeout mechanism when third party is not responding (in time)

* Fourth assignment

- Make the client concurrent
